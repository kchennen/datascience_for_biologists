---
title: "HW7 Instructions"
subtitle: "Data Science for Biologists, Spring 2020"
author: "R script due Thursday 10/29/20 by 12:01 PM to Canvas"
output: 
  html_document:
    highlight: tango
    theme: readable
    css: ../custom-css.css
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, echo = FALSE, include = FALSE)
library(tidyverse)
coffee_ratings <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-07-07/coffee_ratings.csv')
planets <- readr::read_delim("planets.csv", delim = ";")
# do this and save to file, and turn into a question
chickwts %>% mutate(weight = paste(weight, "g")) %>% write_csv("chick_weights.csv") 
chick <- read_csv("chick_weights.csv")
chick %>%
  separate(weight, into=c("weight", "units"), sep = " ")

cap <- read_csv("us-state-capitals.csv")
cap %>% unite(capital, city, state, sep = ", ") 
cap %>% unite(capital, city, state, sep = ", ", remove=FALSE) 

# simplest case: 
#replace_na("unknown")
```


## Instructions

For your assignment, you will be practicing data tidying skills with `tidyr` using several different datasets, many of which stored in the directory `data/`.

Please read these additional instructions carefully:

+ **ALWAYS RUN AND CHECK CODE ONE LINE AT A TIME!!!**
+ Any answers without corresponding code will receive no credit.
+ All plots must be professionally labeled with clean X and Y axes. You are not required to include a title, subtitle, or caption, but you may include one or more of these labels if you choose.
+ All plots using aesthetic color/fill mappings _MUST USE_ a non-default color scale. Similarly, all legend titles must be professionally re-named from their default.
+ When applicable, all saved plots must be clearly legible with an appropriate aspect ratio. This means you may need to change the output plot size using arguments `width` and `height` when calling `ggsave()`. *Make extra sure to LOOK AT YOUR SAVED PLOTS* and tweak the size until it looks clearly professional.
  + You may also need to modify certain theme components to achieve a professional look!
+ Ask me for help AT LEAST 24 hours before the deadline. I cannot guarantee time to help you if only short notice is given. Given my schedule, I can probably (unfortunately) guarantee that I won't have time to help.
+ Write all code yourself and include COMMENTS for each plot you create.
+ Please *comment out* (add `#` in front of) code that causes errors or bugs. This will ensure that your code runs without errors, while also showing me your code attempt if you only got part-way through recreating the plot.

## Questions

> All questions should be answered in the provided hw7.R script template. 

<br>

```
# https://dplyr.tidyverse.org/reference/select.html
coffee_ratings %>% select(where(is.numeric))
coffee_ratings %>% select(contains("altitude"))
```


### Part 1: Fundamental pivoting

1.1. Consider the dataset `algae_co2_uptake.csv`. This dataset contains information about the mean CO2 uptake of algae from three locations exposed to nonchilled and chilled environments. Read in the dataset here, and use the function `pivot_longer()` to tidy the dataset so it looks like this. You should SAVE this dataset to be called `algae_long` (you will use it in the next question).

```{r, include=T}
co2 <- read_csv("algae_co2_uptake.csv")
co2 %>%
  pivot_longer(nonchilled:chilled, names_to ="treatment", values_to = "update")
```

<br><br>

1.2. Write the code required to convert `algae_long` dataset BACK to its wide version using `pivot_wider()`. The resulting dataframe should look exactly like the original dataset read in from `algae_co2_uptake.csv`.

<br><br>

1.3. Consider the dataset called `plant_growth.csv`. This dataset shows crop yields (don't worry about units) for a given plant under two treatments and a control. There are 10 plants, each of which was exposed to all experimental conditions.

This data is currently *tidy*. Make it messy using `pivot_wider()` to end up with a dataframe that looks like this:

```{r, include=T}
plant_growth <- read_csv("plant_growth.csv")
plant_growth %>%
  group_by(group) %>%
  mutate(plant_id = 1:n()) %>%
  pivot_wider(names_from = "group", values_from = "weight")
```

<br><br>

1.4. Use the built-in `msleep` dataset. Create a new version of the dataframe that looks like this:

```{r, include=T}
msleep %>%
  select(name, genus, order) %>%
  pivot_longer(genus:order,names_to = "taxonomic_level", values_to = "group")
```

<br><br>

1.5. Again use the built-in `msleep` dataset and create a new version that looks like this:

> Hint: There are no NA's in my final version output!

```{r, include=T}
msleep %>%
  select(name, brainwt, bodywt) %>%
  pivot_longer(brainwt:bodywt,names_to = "measurement", values_to = "weight") %>%
  drop_na()
```

<br><br>

1.6. Modify your code from the previous question so the final dataframe looks like this. You MUST use `rename()` as part of your code.

> Hint: Rename columns of interest first, and then pivot them. 
>
> Hint 2: Again note the lack of NA's!

```{r, include=T}
msleep %>%
  select(name, brainwt, bodywt) %>%
  rename(brain_mass = brainwt,
         body_mass = bodywt) %>%
  pivot_longer(brain_mass:body_mass,names_to = "measurement", values_to = "weight") %>%
  drop_na()
```

<br><br>

1.6 BONUS: For OPTIONAL bonus points, create the same dataframe but do NOT use `rename()`. Instead, use code that incorporates `mutate()` and `if_else()` to arrive at the final dataset version.

<br><br>

### Part 2: Practicing `select()` magic

When pivoting, we often need to provide a bunch of columns. It is often easier to list these columns using `select()` magic. We have previously seen the magic of `everything()` (select *everything else*!). For this first set of questions, you will teach yourself some more magic by following examples and applying the concept to a new scenario. All examples use a subsetted version of the iris dataset that contains only 3 of each species:

```{r, include=T, echo=T}
iris %>%
  group_by(Species) %>%
  # Add 1-50 for each species - you'll want to run this yourself to see! n() is a useful dplyr function itself
  mutate(row_number = 1:n()) %>%
  # Only keep the first 3 observations per group
  filter(row_number <= 3) %>%
  # We're done with row_number, get rid of it
  select(-row_number) %>%
  # ungroup or else species grouping will remain!
  ungroup() -> iris9

# show iris9:
iris9
```


2.1. Use `starts_with()` to select all columns in `coffee_ratings` that start with the lowercase letter "b".

```{r, echo=T, include=T}
iris9 %>% 
  # Keep only columns whose name starts with "Sepal"
  select(starts_with("Sepal"))
```


<br><br>

2.2. Use `contains()` to select all columns in `coffee_ratings` that contain the word "altitude".

```{r, echo=T, include=T}
iris9 %>% 
    # Keep only columns whose name contains the word "Length"
  select(contains("Length"))
```



2.3. You can use colons to specify a range of columns in order. Use colons to select all columns in `coffee_ratings` aroma through moisture.
```{r, echo=T, include=T}
iris9 %>% 
  # Keep columns Sepal.Length through Petal.Length
  select(Sepal.Length:Petal.Length)
```

2.4. `last_col()` refers to the last column in a dataframe, in the order it appears. Select the last column only in `coffee_ratings`.
```{r, echo=T, include=T}
iris9 %>% 
  # Keep only the last column
  select(last_col())
```

2.5. Combine your colon and `last_col()` skills to select all columns from aroma *through* the last column.

> Hint: Literally use `last_col()` on the right side of the colon!


```{r}
coffee_ratings %>%
  select(aroma:last_col())
```

2.6. `where()` uses a given function *but WITHOUT its normal parentheses*. Use `where()` to select all numeric columns in `coffee_ratings`. Several examples for how to use this function are shown:
```{r, echo=T, include=T}
iris9 %>% 
  # Keep columns where the column is a factor type
  select(where(is.factor))

iris9 %>% 
  # Keep columns where the column is a numeric type
  select(where(is.numeric))

iris9 %>% 
  # Keep columns where the column is a character type
  select(where(is.character))

iris9 %>% 
  # Keep columns where the column is a NOT a numeric type
  select(-where(is.numeric))
```

<br><br>

2.7. Use `where()` to select all character columns in `coffee_ratings`.

<br><br>

2.8. Use `where()` to select all LOGICAL (`is.logical()` is a function you can use here) columns in `coffee_ratings`.

<br><br>

2.9. Consider the dataset in `life_expectancy_years.csv`. This dataset was downloaded from the excellent resource [Gapminder](https://www.gapminder.org/data/), which contains *tons* of free and easily-download datasets about the world. This particular dataset shows life expectancy in years across time for different countries.

We will use this dataset to practice working with non-standard column names: Here, many of the column names start with a NUMBER (well, are a number!). To select columns with numbers, we need to use **backticks** around the columns, i.e. write \`1800\`, not just 1800.

Using backticks when necessary, select only the four columns `country`, `1800`, `1900`, and `2000`.

> Hint: Remember when we normally use `select()` we just plainly list out the columns. There is no fancy function here.


```{r}
life <- read_csv("life_expectancy_years.csv")
life %>% 
  select(country, `1800`, `1900`, `2000`)
```


<br><br>

8. Using a *colon*, select columns `country` and all columns representing the 20th century (1900-1999).

> Hint: The year columns have a backtick around them, NOT the entire range of year columns. Do you have enough backticks??

```{r}
life %>% 
  select(country, `1900`:`1999`)
```

<br><br>

2.9. Use the function `where()` to select all columns that DO NOT contain numeric data. (You should end up with just the `country` column!).

```{r}
life %>% 
  select(-where(is.numeric))
```

### Part 3: Pivoting and wrangling


3.1. Consider the `life_expectancy_years.csv` dataset. In a single connected pipeline that leads directly into `ggplot()`, take the following steps:

+ Wrangle the dataset so it is **fully** tidy
+ Subset the data to ONE country of your over a 20 period of your choice. (Make sure to not choose countries or years with fully missing data!)
+ Plot the data as a *bar graph* showing your country's life expectancy over the 20 year period. Style the plot professionally as we have learned.

> Hint: There are THREE variables here: country, life_expectancy, and year.
>
> Hint 2: `last_col()` will be helpful here so you don't have to figure out what the last year in the dataset is.

```{r}
life %>%
  pivot_longer(`1800`:last_col(), 
               names_to = "year", 
               values_to = "life_expectancy") %>%
  filter(country == "Kazakhstan",
         year %in% 1900:1920) %>%
  ggplot(aes(x = year, y = life_expectancy)) +
  geom_col()

```

<br><br>

3.2. For this question, we will learn how to make a *line plot,* which is a great way to visualize data over time. Line plots are made with `geom_line()` and require an aes called `group` which should map to the variable that indicates *how points should be connected.* 

Again using the life expectancy dataset in a single connected pipeline, pivot to a full tidy dataframe, choose TWO countries over a 10 YEAR PERIOD, and plot their life expectancies over time as a line plot. Guidelines:

+ Make sure the countries are distinguished by color, and also remember to NOT use the default color scheme.
+ In this case, each line represents values for a single *country*. This means that `country` should be mapped to group. If you don't use this aesthetic, the plot will not work properly.
+ You may also want to use `geom_point()` in addition to `geom_line()` so that you can more clearly see the values at each year. Up to you!!

```{r}
life %>%
  pivot_longer(`1800`:last_col(), 
               names_to = "year", 
               values_to = "life_expectancy") %>%
  filter(country %in% c("Bangladesh", "Kazakhstan"),
         year %in% 1950:1970) %>%
  ggplot(aes(x = year, y = life_expectancy, color = country, group = country)) +
  geom_line() + 
  scale_color_brewer(palette = "Set2", name = "Country")
```

<br><br>

3.3.


3.4.



3.5.







Consider the dataset in `abalone.csv`. This dataset contains measurements from several hundred individual abalones, which are sea snails. We


4 questions just pivoting back and forth


## Part 3: Uniting and separating columns

2 questions



#### Question 5

The entire purpose of this question is to show you how awesome the function `tidyr::separate_rows()` is. Read in and examine the (admittedly nerdy) dataset `data/planets.csv` (look at the file - it is delimited by ";" so you should use `read_delim()` and specify the delim as ";"). It is mostly tidy, *except* for the terrain column which contains too many observations!
Clean it up by literally just running this code: `planets %>% separate_rows(terrain)`. Examine the output to understand how unbelievably helpful this function is.

**Then**, there is ONE other column which would benefit from this function. Figure out which one (it's the other one with multiple observations in the rows!) Clean `planets` up with `separate_rows`, and save your final dataset to a new variable. The new variable should have both `terrain` and the other column cleaned properly.



#### Question 6

We will now practice working with columns using `unite` (puts two columns into one - usually but not always makes data "less tidy") and `separate` (separates one column into two - usually but not always makes data "more tidy"). For this question, consider the final dataset you made in question 5 (after all columns that needed it were cleaned with `separate_rows()`.)

Your final answer should pipe all of this together, but build it up STEP BY STEP!!! Don't try to attempt the whole thing at once!!!

+ First, consider the `edited` column - it contains two variables implicitly: date and time. You'll also notice it has a new type: `dttm` which is specifically a format of date and time (that's all we'll really say about this, but read more [here](https://r4ds.had.co.nz/dates-and-times.html)). We want a column for each, so you'll need to separate (perhaps you could use `separate()`?) the column into two (`edited_date` containing just the date, and `edited_time` containing just the time). NOTE: The "UTC" is a nice feature of tidyverse printing and isn't actually in the data (womp). This will separate into two components only, which are currently separated by a space!
+ Second, create a new column called `ratio_period_rotation_orbital` that contains the ratio of `rotation_period` to `orbital_period`. Hint: The purpose of this part is to remind you not to forget `dplyr`! 
+ Third (for practice-sake), unite the columns `name` and `population` to end up with, for example "Alderaan-2000000000", and call this column `name_pop`.
+ Fourth, subset the data to only contain observations (rows!) where the terrain is "mountains". This part serves the same purpose as part 2! Don't forget `dplyr`!
+ Finally, save the dataset such that it is ordered (synyonym: arranged!) by *descending* `ratio_period_rotation_orbital`. Print out the data to show your final result!
